---
title: "Funni Maymay Captions with FFmpeg"
date: 2022-05-19T22:24:44-03:00
draft: false
---

On any chatroom application supporting GIFs, you've likely seem one of those that take a video, speed it up and add a caption. With FFMPEG filters, we can automateâ„¢ that.

# Feeding the video to FFmpeg

Once in possession of source material, you can start building the command line. If the video is already cropped to the moment you want to caption, you can start with:

```sh
ffmpeg -i video.mkv
```

Otherwise, you can crop it with `-ss` (start) and one of `-t` (duration) or `-to` (end), which should come _before_ `-i`. These accept both a simple number of seconds (say, `-ss 120`) and a more traditional timestamp (like `-ss '2:00'`).

```sh
ffmpeg -ss 42 -t 5 -i video.mkv
```

# Processing it

## Downscaling input

After maybe cropping and setting the filename, we're ready to add the inputs and filters. We can process the video part of the input we gave with the `-vf` option. It accepts a _filtergraph_ (the ffmpeg equivalent of a pipeline), which will modify it somehow. The output of the filtergraph will be used as the video part of the output.

For instance, to scale down our video to 320 pixels wide, and keep the ratio between width and height, we can use:

```sh
ffmpeg -i video.mkv -vf 'scale=320:-1'
```

`scale` is the name of the filter. To give it options, we add `=`, plus a colon separated list of options, in this case, width and height. Since the height we gave is negative, ffmpeg will calculate it for us.

I'd recommend using a similar scale filter so your GIF is lighter and font sizes are more consistent.

## Speedup

The ffmpeg filter `setpts` allows you to speed up or slow down the video. I don't have the background in video engineering to fully grasp what a PTS is, but tl;dr use `setpts=PTS/$SPEEDUP` as a filter to speed up the video (for instance, `setpts=PTS/2` for a 2x speedup, or `setpts=2*PTS` for a 2x slowdown).

For instace, a 3x speedup:

```sh
ffmpeg -i video.mkv -vf 'scale=320:-1,setpts=PTS/3'
```

## Padding

If you want a blank spot above the video for your text, you can use the `pad` filter. As `pad` has more useful options than `scale`, we'll use the alternative syntax for ffmpeg filters that explicitly names each option insted of there being an implicit order, `filter=option1=value1:option2=value2`. I think being more verbose here is worth it for clarity.

We can adjust the output width and height by using the `width` and `height` option, and the position the original video with `x` and `y` (by default, both are zero, meaning the top left corner). The color of the padding can be controlled with the `color` option.

An interesting bit I didn't mention, but you might have noticed in the speedup section, is that ffmpeg allows variables and math within numerical values. The `pad` filter, for example, provides the `iw` and `ih` variables, which refer to width and height of the original video. So, to create a black area on top, you'd use `pad=y=50:height=ih+50`.

If you do use padding, remember to reposition the text accordingly.

## Adding words

Now for the text caption itself. For this, we'll use ffmpeg's `drawtext` filter.

Either way, the main option in `drawtext` is, well, the `text` itself, which we can specify with `text=Something`.

By default, the text is located at the top left corner of the video, but you can reposition it with the `x` and `y` options. ; for example it provides `w`/`h` (video width/height) and `tw`/`th` (generated text width/height). For example, to center the text, you'd use `x=w/2-th/2`. You can perform similar math on the Y axis to position it, for example, in the bottom eigthth, lower third, etc.

`font`, `fontcolor` and `fontsize` are pretty self-explanatory, I think.

```sh
ffmpeg -i video.mkv -vf 'scale=320:-1,setpts=PTS/3,drawtext=text=When I abcdef:x=(w-tw)/2:y=7*h/8-th/2:fontcolor=white:fontsize=24'
```

## Making the GIF look good

By default, GIFs output by FFmpeg have "wrong" colors. This can be fixed by using three filters, `split`, `palettegen` and `paletteuse`. These are more complicated than the previous filters in that they have multiple inputs and outputs, and we'll need to use labels.

First of all, just like in shell scripts you have to use `tee` command to copy the same input to multiple files or programs, in ffmpeg you need to use `split` filter to give the same input to multiple filters. To label the outputs of split (copies of its input), you use a name surrounded by square brackets:

```sh
ffmpeg -i video.mkv -vf 'scale=320:-1,split[a][b]'
```

This will make two copies of the output of the scale, labeled `a` and `b`.

`palettegen` accepts a video as input and generates a GIF palette for it. `paletteuse` accepts a copy of the original video and the GIF palette generated by `palettegen`, outputting a better-looking GIF instead of the mess that ffmpeg produces by default.

As `scale...split`, `palettegen` and `paletteuse` are ultimately different filtergraphs/pipelines with different inputs and outputs, they need to be separated with semicolons (`;`).

```sh
ffmpeg -i video.mkv -vf 'scale=320:-1,split[a][b] ; [a]palettegen[pal] ; [b][pal]paletteuse' video.gif
```

`palettegen`'s output is labeled `pal`, we add another semicolon, and use `b` and `pal` as the inputs for `paletteuse`. The output of `paletteuse` becomes the final GIF.

The spaces around the semicolons are optional; they're here for clarity.

# Warning: FFmpeg escaping

One thing to keep in mind when writing scripts accepting input from users, from `man 1 ffmpeg-filters`:

> A first level escaping affects the content of each filter option value,
> which may contain the special character `:` used to separate values, or
> one of the escaping characters `\'`.
>
> A second level escaping affects the whole filter description, which may
> contain the escaping characters `\'` or the special characters `[],;`
> used by the filtergraph description.

This will definitely lead to a cursed proliferation of backlashes on the string. We'd need to escape the `\` themselves, then all of `\':`, then all of `\'[],;`.

```sh
sed "s/\\\\/\\\\&/g;s/[:\\\\']/\\\\&/g;s/[],;\\\\'[]/\\\\&/g"
```

(You also have to escape backslashes within shell double quotes...)


# Example results

Creating a script with usage: `./caption [ -p ] [ -s SPEED ] [ -o output ] text video` (-p for padding):

```sh
#!/bin/sh
# Defaults:
PAD_FILTER='null' # no padding
SPEED_FILTER='null' # no speedup
OUTPUT="${VIDEO%.*}.gif" # same name as original file, but with gif suffix
TEXT_Y='(7*h)/8-th/2' # text on the lower eighth

while getopts po:s: opt; do
	case $opt in
		p)
			# Height of the padding is 50, and background will be white.
			PAD_FILTER='pad=height=ih+50:y=50:color=white'
			# We'll center the text on the added padding.
			TEXT_Y='(50-th)/2'
			;;
		s)
			# Remember the formula in the speed up section.
			SPEED_FILTER="setpts=PTS/${OPTARG}"
			;;
		o)
			OUTPUT="$OPTARG"
			;;
		\?)
			exit 1
			;;
	esac
done

shift $((OPTIND-1))

TEXT=${1?No text}
VIDEO=${2?No video}

# Escape from the escape hell
TEXT=$(printf '%s' "$TEXT" | sed "s/\\\\/\\\\&/g;s/[:\\\\']/\\\\&/g;s/[],;\\\\'[]/\\\\&/g")

# Using line continuations here so the boundary between filters is clearer.
ffmpeg -i "$VIDEO" -vf "scale=320:-1,\
${SPEED_FILTER},${PAD_FILTER},\
drawtext=text=${TEXT}:x=w/2-tw/2:y=${TEXT_Y}:fontcolor=black:fontsize=24,\
split[a][b] ;\
[a]palettegen[pal] ;\
[b][pal]paletteuse" "$OUTPUT"
```

# Further reading

- `man 1 ffmpeg-filters`
