<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Funni Maymay Captions with FFmpeg | Cape&#39;s Corner</title>
<meta name="keywords" content="">
<meta name="description" content="On any chatroom application supporting GIFs, you&rsquo;ve likely seem one of those that take a video, speed it up and add a caption. With FFMPEG filters, we can automate™ that.
Feeding the video to FFmpeg Once in possession of source material, you can start building the command line. If the video is already cropped to the moment you want to caption, you can start with:
ffmpeg -i video.mkv Otherwise, you can crop it with -ss (start) and one of -t (duration) or -to (end), which should come before -i.">
<meta name="author" content="">
<link rel="canonical" href="http://capezotte.github.io/posts/captioning-memes-ffmpeg/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.ec8da366ca2fb647537ccb7a8f6fa5b4e9cd3c7a0d3171dd2d3baad1e49c8bfc.css" integrity="sha256-7I2jZsovtkdTfMt6j2&#43;ltOnNPHoNMXHdLTuq0eSci/w=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js" integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://capezotte.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://capezotte.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://capezotte.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://capezotte.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="http://capezotte.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Funni Maymay Captions with FFmpeg" />
<meta property="og:description" content="On any chatroom application supporting GIFs, you&rsquo;ve likely seem one of those that take a video, speed it up and add a caption. With FFMPEG filters, we can automate™ that.
Feeding the video to FFmpeg Once in possession of source material, you can start building the command line. If the video is already cropped to the moment you want to caption, you can start with:
ffmpeg -i video.mkv Otherwise, you can crop it with -ss (start) and one of -t (duration) or -to (end), which should come before -i." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://capezotte.github.io/posts/captioning-memes-ffmpeg/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-19T22:24:44-03:00" />
<meta property="article:modified_time" content="2022-05-19T22:24:44-03:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Funni Maymay Captions with FFmpeg"/>
<meta name="twitter:description" content="On any chatroom application supporting GIFs, you&rsquo;ve likely seem one of those that take a video, speed it up and add a caption. With FFMPEG filters, we can automate™ that.
Feeding the video to FFmpeg Once in possession of source material, you can start building the command line. If the video is already cropped to the moment you want to caption, you can start with:
ffmpeg -i video.mkv Otherwise, you can crop it with -ss (start) and one of -t (duration) or -to (end), which should come before -i."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "http://capezotte.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Funni Maymay Captions with FFmpeg",
      "item": "http://capezotte.github.io/posts/captioning-memes-ffmpeg/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Funni Maymay Captions with FFmpeg",
  "name": "Funni Maymay Captions with FFmpeg",
  "description": "On any chatroom application supporting GIFs, you\u0026rsquo;ve likely seem one of those that take a video, speed it up and add a caption. With FFMPEG filters, we can automate™ that.\nFeeding the video to FFmpeg Once in possession of source material, you can start building the command line. If the video is already cropped to the moment you want to caption, you can start with:\nffmpeg -i video.mkv Otherwise, you can crop it with -ss (start) and one of -t (duration) or -to (end), which should come before -i.",
  "keywords": [
    
  ],
  "articleBody": "On any chatroom application supporting GIFs, you’ve likely seem one of those that take a video, speed it up and add a caption. With FFMPEG filters, we can automate™ that.\nFeeding the video to FFmpeg Once in possession of source material, you can start building the command line. If the video is already cropped to the moment you want to caption, you can start with:\nffmpeg -i video.mkv Otherwise, you can crop it with -ss (start) and one of -t (duration) or -to (end), which should come before -i. These accept both a simple number of seconds (say, -ss 120) and a more traditional timestamp (like -ss '2:00').\nffmpeg -ss 42 -t 5 -i video.mkv Processing it Downscaling input After maybe cropping and setting the filename, we’re ready to add the inputs and filters. We can process the video part of the input we gave with the -vf option. It accepts a filtergraph (the ffmpeg equivalent of a pipeline), which will modify it somehow. The output of the filtergraph will be used as the video part of the output.\nFor instance, to scale down our video to 320 pixels wide, and keep the ratio between width and height, we can use:\nffmpeg -i video.mkv -vf 'scale=320:-1' scale is the name of the filter. To give it options, we add =, plus a colon separated list of options, in this case, width and height. Since the height we gave is negative, ffmpeg will calculate it for us.\nI’d recommend using a similar scale filter so your GIF is lighter and font sizes are more consistent.\nSpeedup The ffmpeg filter setpts allows you to speed up or slow down the video. I don’t have the background in video engineering to fully grasp what a PTS is, but tl;dr use setpts=PTS/$SPEEDUP as a filter to speed up the video (for instance, setpts=PTS/2 for a 2x speedup, or setpts=2*PTS for a 2x slowdown).\nFor instace, a 3x speedup:\nffmpeg -i video.mkv -vf 'scale=320:-1,setpts=PTS/3' Padding If you want a blank spot above the video for your text, you can use the pad filter. As pad has more useful options than scale, we’ll use the alternative syntax for ffmpeg filters that explicitly names each option insted of there being an implicit order, filter=option1=value1:option2=value2. I think being more verbose here is worth it for clarity.\nWe can adjust the output width and height by using the width and height option, and the position the original video with x and y (by default, both are zero, meaning the top left corner). The color of the padding can be controlled with the color option.\nAn interesting bit I didn’t mention, but you might have noticed in the speedup section, is that ffmpeg allows variables and math within numerical values. The pad filter, for example, provides the iw and ih variables, which refer to width and height of the original video. So, to create a black area on top, you’d use pad=y=50:height=ih+50.\nIf you do use padding, remember to reposition the text accordingly.\nAdding words Now for the text caption itself. For this, we’ll use ffmpeg’s drawtext filter.\nEither way, the main option in drawtext is, well, the text itself, which we can specify with text=Something.\nBy default, the text is located at the top left corner of the video, but you can reposition it with the x and y options. ; for example it provides w/h (video width/height) and tw/th (generated text width/height). For example, to center the text, you’d use x=w/2-th/2. You can perform similar math on the Y axis to position it, for example, in the bottom eigthth, lower third, etc.\nfont, fontcolor and fontsize are pretty self-explanatory, I think.\nffmpeg -i video.mkv -vf 'scale=320:-1,setpts=PTS/3,drawtext=text=When I abcdef:x=(w-tw)/2:y=7*h/8-th/2:fontcolor=white:fontsize=24' Making the GIF look good By default, GIFs output by FFmpeg have “wrong” colors. This can be fixed by using three filters, split, palettegen and paletteuse. These are more complicated than the previous filters in that they have multiple inputs and outputs, and we’ll need to use labels.\nFirst of all, just like in shell scripts you have to use tee command to copy the same input to multiple files or programs, in ffmpeg you need to use split filter to give the same input to multiple filters. To label the outputs of split (copies of its input), you use a name surrounded by square brackets:\nffmpeg -i video.mkv -vf 'scale=320:-1,split[a][b]' This will make two copies of the output of the scale, labeled a and b.\npalettegen accepts a video as input and generates a GIF palette for it. paletteuse accepts a copy of the original video and the GIF palette generated by palettegen, outputting a better-looking GIF instead of the mess that ffmpeg produces by default.\nAs scale...split, palettegen and paletteuse are ultimately different filtergraphs/pipelines with different inputs and outputs, they need to be separated with semicolons (;).\nffmpeg -i video.mkv -vf 'scale=320:-1,split[a][b] ; [a]palettegen[pal] ; [b][pal]paletteuse' video.gif palettegen’s output is labeled pal, we add another semicolon, and use b and pal as the inputs for paletteuse. The output of paletteuse becomes the final GIF.\nThe spaces around the semicolons are optional; they’re here for clarity.\nWarning: FFmpeg escaping One thing to keep in mind when writing scripts accepting input from users, from man 1 ffmpeg-filters:\n A first level escaping affects the content of each filter option value, which may contain the special character : used to separate values, or one of the escaping characters \\'.\nA second level escaping affects the whole filter description, which may contain the escaping characters \\' or the special characters [],; used by the filtergraph description.\n This will definitely lead to a cursed proliferation of backlashes on the string. We’d need to escape the \\ themselves, then all of \\':, then all of \\'[],;.\nsed \"s/\\\\\\\\/\\\\\\\\\u0026/g;s/[:\\\\\\\\']/\\\\\\\\\u0026/g;s/[],;\\\\\\\\'[]/\\\\\\\\\u0026/g\" (You also have to escape backslashes within shell double quotes…)\nExample results Creating a script with usage: ./caption [ -p ] [ -s SPEED ] [ -o output ] text video (-p for padding):\n#!/bin/sh # Defaults: PAD_FILTER='null' # no padding SPEED_FILTER='null' # no speedup OUTPUT=\"${VIDEO%.*}.gif\" # same name as original file, but with gif suffix TEXT_Y='(7*h)/8-th/2' # text on the lower eighth  while getopts po:s: opt; do \tcase $opt in \tp) \t# Height of the padding is 50, and background will be white. \tPAD_FILTER='pad=height=ih+50:y=50:color=white' \t# We'll center the text on the added padding. \tTEXT_Y='(50-th)/2' \t;; \ts) \t# Remember the formula in the speed up section. \tSPEED_FILTER=\"setpts=PTS/${OPTARG}\" \t;; \to) \tOUTPUT=\"$OPTARG\" \t;; \t\\?) \texit 1 \t;; \tesac done  shift $((OPTIND-1))  TEXT=${1?No text} VIDEO=${2?No video}  # Escape from the escape hell TEXT=$(printf '%s' \"$TEXT\" | sed \"s/\\\\\\\\/\\\\\\\\\u0026/g;s/[:\\\\\\\\']/\\\\\\\\\u0026/g;s/[],;\\\\\\\\'[]/\\\\\\\\\u0026/g\")  # Using line continuations here so the boundary between filters is clearer. ffmpeg -i \"$VIDEO\" -vf \"scale=320:-1,\\ ${SPEED_FILTER},${PAD_FILTER},\\ drawtext=text=${TEXT}:x=w/2-tw/2:y=${TEXT_Y}:fontcolor=black:fontsize=24,\\ split[a][b] ;\\ [a]palettegen[pal] ;\\ [b][pal]paletteuse\" \"$OUTPUT\" Further reading  man 1 ffmpeg-filters  ",
  "wordCount" : "1128",
  "inLanguage": "en",
  "datePublished": "2022-05-19T22:24:44-03:00",
  "dateModified": "2022-05-19T22:24:44-03:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://capezotte.github.io/posts/captioning-memes-ffmpeg/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Cape's Corner",
    "logo": {
      "@type": "ImageObject",
      "url": "http://capezotte.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://capezotte.github.io/" accesskey="h" title="Cape&#39;s Corner (Alt + H)">Cape&#39;s Corner</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Funni Maymay Captions with FFmpeg
    </h1>
    <div class="post-meta"><span title='2022-05-19 22:24:44 -0300 -03'>May 19, 2022</span>

</div>
  </header> 
  <div class="post-content"><p>On any chatroom application supporting GIFs, you&rsquo;ve likely seem one of those that take a video, speed it up and add a caption. With FFMPEG filters, we can automate™ that.</p>
<h1 id="feeding-the-video-to-ffmpeg">Feeding the video to FFmpeg<a hidden class="anchor" aria-hidden="true" href="#feeding-the-video-to-ffmpeg">#</a></h1>
<p>Once in possession of source material, you can start building the command line. If the video is already cropped to the moment you want to caption, you can start with:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>ffmpeg -i video.mkv
</span></span></code></pre></div><p>Otherwise, you can crop it with <code>-ss</code> (start) and one of <code>-t</code> (duration) or <code>-to</code> (end), which should come <em>before</em> <code>-i</code>. These accept both a simple number of seconds (say, <code>-ss 120</code>) and a more traditional timestamp (like <code>-ss '2:00'</code>).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>ffmpeg -ss <span style="color:#ae81ff">42</span> -t <span style="color:#ae81ff">5</span> -i video.mkv
</span></span></code></pre></div><h1 id="processing-it">Processing it<a hidden class="anchor" aria-hidden="true" href="#processing-it">#</a></h1>
<h2 id="downscaling-input">Downscaling input<a hidden class="anchor" aria-hidden="true" href="#downscaling-input">#</a></h2>
<p>After maybe cropping and setting the filename, we&rsquo;re ready to add the inputs and filters. We can process the video part of the input we gave with the <code>-vf</code> option. It accepts a <em>filtergraph</em> (the ffmpeg equivalent of a pipeline), which will modify it somehow. The output of the filtergraph will be used as the video part of the output.</p>
<p>For instance, to scale down our video to 320 pixels wide, and keep the ratio between width and height, we can use:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>ffmpeg -i video.mkv -vf <span style="color:#e6db74">&#39;scale=320:-1&#39;</span>
</span></span></code></pre></div><p><code>scale</code> is the name of the filter. To give it options, we add <code>=</code>, plus a colon separated list of options, in this case, width and height. Since the height we gave is negative, ffmpeg will calculate it for us.</p>
<p>I&rsquo;d recommend using a similar scale filter so your GIF is lighter and font sizes are more consistent.</p>
<h2 id="speedup">Speedup<a hidden class="anchor" aria-hidden="true" href="#speedup">#</a></h2>
<p>The ffmpeg filter <code>setpts</code> allows you to speed up or slow down the video. I don&rsquo;t have the background in video engineering to fully grasp what a PTS is, but tl;dr use <code>setpts=PTS/$SPEEDUP</code> as a filter to speed up the video (for instance, <code>setpts=PTS/2</code> for a 2x speedup, or <code>setpts=2*PTS</code> for a 2x slowdown).</p>
<p>For instace, a 3x speedup:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>ffmpeg -i video.mkv -vf <span style="color:#e6db74">&#39;scale=320:-1,setpts=PTS/3&#39;</span>
</span></span></code></pre></div><h2 id="padding">Padding<a hidden class="anchor" aria-hidden="true" href="#padding">#</a></h2>
<p>If you want a blank spot above the video for your text, you can use the <code>pad</code> filter. As <code>pad</code> has more useful options than <code>scale</code>, we&rsquo;ll use the alternative syntax for ffmpeg filters that explicitly names each option insted of there being an implicit order, <code>filter=option1=value1:option2=value2</code>. I think being more verbose here is worth it for clarity.</p>
<p>We can adjust the output width and height by using the <code>width</code> and <code>height</code> option, and the position the original video with <code>x</code> and <code>y</code> (by default, both are zero, meaning the top left corner). The color of the padding can be controlled with the <code>color</code> option.</p>
<p>An interesting bit I didn&rsquo;t mention, but you might have noticed in the speedup section, is that ffmpeg allows variables and math within numerical values. The <code>pad</code> filter, for example, provides the <code>iw</code> and <code>ih</code> variables, which refer to width and height of the original video. So, to create a black area on top, you&rsquo;d use <code>pad=y=50:height=ih+50</code>.</p>
<p>If you do use padding, remember to reposition the text accordingly.</p>
<h2 id="adding-words">Adding words<a hidden class="anchor" aria-hidden="true" href="#adding-words">#</a></h2>
<p>Now for the text caption itself. For this, we&rsquo;ll use ffmpeg&rsquo;s <code>drawtext</code> filter.</p>
<p>Either way, the main option in <code>drawtext</code> is, well, the <code>text</code> itself, which we can specify with <code>text=Something</code>.</p>
<p>By default, the text is located at the top left corner of the video, but you can reposition it with the <code>x</code> and <code>y</code> options. ; for example it provides <code>w</code>/<code>h</code> (video width/height) and <code>tw</code>/<code>th</code> (generated text width/height). For example, to center the text, you&rsquo;d use <code>x=w/2-th/2</code>. You can perform similar math on the Y axis to position it, for example, in the bottom eigthth, lower third, etc.</p>
<p><code>font</code>, <code>fontcolor</code> and <code>fontsize</code> are pretty self-explanatory, I think.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>ffmpeg -i video.mkv -vf <span style="color:#e6db74">&#39;scale=320:-1,setpts=PTS/3,drawtext=text=When I abcdef:x=(w-tw)/2:y=7*h/8-th/2:fontcolor=white:fontsize=24&#39;</span>
</span></span></code></pre></div><h2 id="making-the-gif-look-good">Making the GIF look good<a hidden class="anchor" aria-hidden="true" href="#making-the-gif-look-good">#</a></h2>
<p>By default, GIFs output by FFmpeg have &ldquo;wrong&rdquo; colors. This can be fixed by using three filters, <code>split</code>, <code>palettegen</code> and <code>paletteuse</code>. These are more complicated than the previous filters in that they have multiple inputs and outputs, and we&rsquo;ll need to use labels.</p>
<p>First of all, just like in shell scripts you have to use <code>tee</code> command to copy the same input to multiple files or programs, in ffmpeg you need to use <code>split</code> filter to give the same input to multiple filters. To label the outputs of split (copies of its input), you use a name surrounded by square brackets:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>ffmpeg -i video.mkv -vf <span style="color:#e6db74">&#39;scale=320:-1,split[a][b]&#39;</span>
</span></span></code></pre></div><p>This will make two copies of the output of the scale, labeled <code>a</code> and <code>b</code>.</p>
<p><code>palettegen</code> accepts a video as input and generates a GIF palette for it. <code>paletteuse</code> accepts a copy of the original video and the GIF palette generated by <code>palettegen</code>, outputting a better-looking GIF instead of the mess that ffmpeg produces by default.</p>
<p>As <code>scale...split</code>, <code>palettegen</code> and <code>paletteuse</code> are ultimately different filtergraphs/pipelines with different inputs and outputs, they need to be separated with semicolons (<code>;</code>).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>ffmpeg -i video.mkv -vf <span style="color:#e6db74">&#39;scale=320:-1,split[a][b] ; [a]palettegen[pal] ; [b][pal]paletteuse&#39;</span> video.gif
</span></span></code></pre></div><p><code>palettegen</code>&rsquo;s output is labeled <code>pal</code>, we add another semicolon, and use <code>b</code> and <code>pal</code> as the inputs for <code>paletteuse</code>. The output of <code>paletteuse</code> becomes the final GIF.</p>
<p>The spaces around the semicolons are optional; they&rsquo;re here for clarity.</p>
<h1 id="warning-ffmpeg-escaping">Warning: FFmpeg escaping<a hidden class="anchor" aria-hidden="true" href="#warning-ffmpeg-escaping">#</a></h1>
<p>One thing to keep in mind when writing scripts accepting input from users, from <code>man 1 ffmpeg-filters</code>:</p>
<blockquote>
<p>A first level escaping affects the content of each filter option value,
which may contain the special character <code>:</code> used to separate values, or
one of the escaping characters <code>\'</code>.</p>
<p>A second level escaping affects the whole filter description, which may
contain the escaping characters <code>\'</code> or the special characters <code>[],;</code>
used by the filtergraph description.</p>
</blockquote>
<p>This will definitely lead to a cursed proliferation of backlashes on the string. We&rsquo;d need to escape the <code>\</code> themselves, then all of <code>\':</code>, then all of <code>\'[],;</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sed <span style="color:#e6db74">&#34;s/\\\\/\\\\&amp;/g;s/[:\\\\&#39;]/\\\\&amp;/g;s/[],;\\\\&#39;[]/\\\\&amp;/g&#34;</span>
</span></span></code></pre></div><p>(You also have to escape backslashes within shell double quotes&hellip;)</p>
<h1 id="example-results">Example results<a hidden class="anchor" aria-hidden="true" href="#example-results">#</a></h1>
<p>Creating a script with usage: <code>./caption [ -p ] [ -s SPEED ] [ -o output ] text video</code> (-p for padding):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e">#!/bin/sh
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e"># Defaults:</span>
</span></span><span style="display:flex;"><span>PAD_FILTER<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;null&#39;</span> <span style="color:#75715e"># no padding</span>
</span></span><span style="display:flex;"><span>SPEED_FILTER<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;null&#39;</span> <span style="color:#75715e"># no speedup</span>
</span></span><span style="display:flex;"><span>OUTPUT<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>VIDEO%.*<span style="color:#e6db74">}</span><span style="color:#e6db74">.gif&#34;</span> <span style="color:#75715e"># same name as original file, but with gif suffix</span>
</span></span><span style="display:flex;"><span>TEXT_Y<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;(7*h)/8-th/2&#39;</span> <span style="color:#75715e"># text on the lower eighth</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> getopts po:s: opt; <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> $opt in
</span></span><span style="display:flex;"><span>		p<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e"># Height of the padding is 50, and background will be white.</span>
</span></span><span style="display:flex;"><span>			PAD_FILTER<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;pad=height=ih+50:y=50:color=white&#39;</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e"># We&#39;ll center the text on the added padding.</span>
</span></span><span style="display:flex;"><span>			TEXT_Y<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;(50-th)/2&#39;</span>
</span></span><span style="display:flex;"><span>			;;
</span></span><span style="display:flex;"><span>		s<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e"># Remember the formula in the speed up section.</span>
</span></span><span style="display:flex;"><span>			SPEED_FILTER<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;setpts=PTS/</span><span style="color:#e6db74">${</span>OPTARG<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>			;;
</span></span><span style="display:flex;"><span>		o<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>			OUTPUT<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$OPTARG<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>			;;
</span></span><span style="display:flex;"><span>		<span style="color:#ae81ff">\?</span><span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>			exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>			;;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">esac</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">done</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>shift <span style="color:#66d9ef">$((</span>OPTIND-1<span style="color:#66d9ef">))</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>TEXT<span style="color:#f92672">=</span><span style="color:#e6db74">${</span>1?No text<span style="color:#e6db74">}</span>
</span></span><span style="display:flex;"><span>VIDEO<span style="color:#f92672">=</span><span style="color:#e6db74">${</span>2?No video<span style="color:#e6db74">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Escape from the escape hell</span>
</span></span><span style="display:flex;"><span>TEXT<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>printf <span style="color:#e6db74">&#39;%s&#39;</span> <span style="color:#e6db74">&#34;</span>$TEXT<span style="color:#e6db74">&#34;</span> | sed <span style="color:#e6db74">&#34;s/\\\\/\\\\&amp;/g;s/[:\\\\&#39;]/\\\\&amp;/g;s/[],;\\\\&#39;[]/\\\\&amp;/g&#34;</span><span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Using line continuations here so the boundary between filters is clearer.</span>
</span></span><span style="display:flex;"><span>ffmpeg -i <span style="color:#e6db74">&#34;</span>$VIDEO<span style="color:#e6db74">&#34;</span> -vf <span style="color:#e6db74">&#34;scale=320:-1,\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"></span><span style="color:#e6db74">${</span>SPEED_FILTER<span style="color:#e6db74">}</span><span style="color:#e6db74">,</span><span style="color:#e6db74">${</span>PAD_FILTER<span style="color:#e6db74">}</span><span style="color:#e6db74">,\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">drawtext=text=</span><span style="color:#e6db74">${</span>TEXT<span style="color:#e6db74">}</span><span style="color:#e6db74">:x=w/2-tw/2:y=</span><span style="color:#e6db74">${</span>TEXT_Y<span style="color:#e6db74">}</span><span style="color:#e6db74">:fontcolor=black:fontsize=24,\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">split[a][b] ;\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">[a]palettegen[pal] ;\
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">[b][pal]paletteuse&#34;</span> <span style="color:#e6db74">&#34;</span>$OUTPUT<span style="color:#e6db74">&#34;</span>
</span></span></code></pre></div><h1 id="further-reading">Further reading<a hidden class="anchor" aria-hidden="true" href="#further-reading">#</a></h1>
<ul>
<li><code>man 1 ffmpeg-filters</code></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>© Carlos. Verbatim reproductions with attribution are freely allowed.</span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
